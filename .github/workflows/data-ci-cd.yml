# Nom du workflow tel qu’il apparaîtra dans GitHub Actions
name: Data CI/CD Pipeline

# Déclencheurs du pipeline
on:
  # Le pipeline s’exécute à chaque Pull Request
  pull_request:
  # Le pipeline s’exécute aussi à chaque push sur la branche main
  push:
    branches: [ main ]

jobs:
  # =====================================================
  # 1. VALIDATION DU CODE (Linting & qualité)
  # =====================================================
  lint:
    # Nom lisible du job dans l’interface GitHub
    name: Lint & Qualité du code

    # Environnement d’exécution (machine virtuelle Linux)
    runs-on: ubuntu-latest

    steps:
      # Étape 1 : récupération du code source
      - name: Checkout du code
        uses: actions/checkout@v4

      # Étape 2 : installation de Python
      - name: Installer Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # Étape 3 : installation de l’outil de linting
      - name: Installer dépendances
        run: |
          pip install ruff

      # Étape 4 : analyse statique du code
      # Objectif : échouer rapidement si le code est non conforme
      - name: Linting (fail fast)
        run: |
          ruff check .

  # =====================================================
  # 2. TESTS UNITAIRES (transformations de données)
  # =====================================================
  unit-tests:
    name: Tests unitaires (transformations data)

    # Le job ne démarre que si le linting a réussi
    needs: lint

    runs-on: ubuntu-latest

    steps:
      # Récupération du code
      - uses: actions/checkout@v4

      # Installation de Python
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # Installation des dépendances du projet + pytest
      - name: Installer dépendances
        run: |
          pip install -r app/requirements.txt
          pip install pytest

      # Exécution des tests unitaires
      # Ici : fonctions de transformation, nettoyage, calculs KPI
      - name: Lancer tests unitaires
        run: |
          export PYTHONPATH="${PYTHONPATH}:${PWD}"
          pytest tests/unit

  # =====================================================
  # 3. TESTS D’INTÉGRATION (base de données + données)
  # =====================================================
  integration-tests:
    name: Tests d’intégration (base + données)

    # Dépend des tests unitaires
    needs: unit-tests

    runs-on: ubuntu-latest

    steps:
      # Récupération du code
      - uses: actions/checkout@v4

      # Installation de Python
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # Installation des dépendances nécessaires aux tests DB
      - name: Installer dépendances
        run: |
          pip install -r app/requirements.txt
          pip install pytest

      # Exécution des tests d’intégration
      # Objectif : tester les requêtes SQL, le schéma et les interactions réelles
      - name: Lancer tests d’intégration
        run: |
          export PYTHONPATH="${PYTHONPATH}:${PWD}"
          pytest tests/integration

  # =====================================================
  # 4. TESTS DE PERFORMANCE (simples)
  # =====================================================
  performance-tests:
    name: Validation des performances

    # Ne démarre que si les tests d’intégration passent
    needs: integration-tests

    runs-on: ubuntu-latest

    steps:
      # Récupération du code
      - uses: actions/checkout@v4

      # Installation de Python
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # Installation des outils de benchmark
      - name: Installer dépendances
        run: |
          pip install -r app/requirements.txt
          pip install pytest pytest-benchmark

      # Exécution de benchmarks légers
      # Objectif : détecter des régressions de performance
      - name: Benchmarks légers
        run: |
          export PYTHONPATH="${PYTHONPATH}:${PWD}"
          pytest tests/performance --benchmark-only

  # =====================================================
  # 5. DÉPLOIEMENT 
  # =====================================================
  deploy:
    name: Déploiement progressif (staging → prod)

    # Le déploiement ne se fait que si tous les tests ont réussi
    needs: performance-tests

    runs-on: ubuntu-latest

    # Condition : uniquement sur la branche main
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Set Docker image tag
        run: |
          IMAGE_NAME="ghcr.io/${{ github.repository }}/app-python:latest"
          IMAGE_NAME_LOWER=$(echo "$IMAGE_NAME" | tr '[:upper:]' '[:lower:]')
          echo "IMAGE_TAG=$IMAGE_NAME_LOWER" >> $GITHUB_ENV
          echo "Image tag set to: $IMAGE_NAME_LOWER"
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./app
          file: ./app/Dockerfile
          push: true
          tags: ${{ env.IMAGE_TAG }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Generate secrets YAML from GitHub Secrets
        env:
          APP_DB_PATH: ${{ secrets.APP_DB_PATH }}
        run: |
          set -e
          
          # Créer le dossier k8s
          mkdir -p PaulineSoubrieAppPython
          
          # Fonction pour encoder en base64
          encode_base64() {
            echo -n "$1" | base64
          }
          
          # Générer le fichier yaml des secrets
          cat > PaulineSoubrieAppPython/secrets.yaml <<EOF
          ---
          apiVersion: v1
          kind: Secret
          metadata:
            name: app-db-path
          type: Opaque
          data:
            app_db_path: $(encode_base64 "${APP_DB_PATH:-/tmp/app.db}")
          EOF

          echo "Fichier secrets.yaml généré avec succès"
      
      - name: Install Kompose
        run: |
          curl -L https://github.com/kubernetes/kompose/releases/download/v1.38.0/kompose-linux-amd64 -o kompose
          chmod +x kompose
          sudo mv kompose /usr/local/bin/kompose
      
      - name: Convert docker-compose to Kubernetes manifests
        run: |
          kompose convert -f docker-compose.yml -o PaulineSoubrieAppPython/
      
      - name: Fix deployments to use secrets and Docker image
        env:
          DOCKER_IMAGE: ${{ env.IMAGE_TAG }}
        run: |
          # Installer PyYAML pour modifier les YAML
          pip3 install pyyaml --quiet
          
          # Script Python pour corriger les déploiements
          python3 <<PYEOF
          import yaml
          import sys
          import glob
          import os
          
          # Image Docker à utiliser
          docker_image = os.environ.get('DOCKER_IMAGE')
          if not docker_image:
              raise ValueError("DOCKER_IMAGE environment variable is not set")
          
          # Trouver le fichier de déploiement de l'app
          deployment_files = glob.glob('PaulineSoubrieAppPython/*-deployment.yaml')
          
          for deployment_file in deployment_files:
              try:
                  with open(deployment_file, 'r') as f:
                      doc = yaml.safe_load(f)
                  
                  container = doc['spec']['template']['spec']['containers'][0]
                  
                  # Mettre à jour l'image Docker
                  container['image'] = docker_image
                  print(f"✅ Image mise à jour vers {docker_image}")
                  
                  env_vars = container.get('env', [])
                  
                  # Mapping des variables aux secrets
                  secret_mapping = {
                      'APP_DB_PATH': {'secret': 'app-db-path', 'key': 'app_db_path'}
                  }
                  
                  # Remplacer les variables d'environnement vides par des références aux secrets
                  new_env = []
                  for var in env_vars:
                      var_name = var.get('name', '')
                      if var_name in secret_mapping:
                          mapping = secret_mapping[var_name]
                          new_env.append({
                              'name': var_name,
                              'valueFrom': {
                                  'secretKeyRef': {
                                      'name': mapping['secret'],
                                      'key': mapping['key']
                                  }
                              }
                          })
                      else:
                          new_env.append(var)
                  
                  container['env'] = new_env
                  
                  with open(deployment_file, 'w') as f:
                      yaml.dump(doc, f, default_flow_style=False, sort_keys=False, allow_unicode=True)
                  
                  print(f"✅ Déploiement {deployment_file} corrigé pour utiliser les secrets et l'image Docker")
              except Exception as e:
                  print(f"⚠️ Erreur lors du traitement de {deployment_file}: {e}")
                  pass
          
          print("✅ Déploiements corrigés pour utiliser les secrets et l'image Docker")
          PYEOF
      
      - name: Zip Kubernetes YAML files and README
        run: |
          cp README.md PaulineSoubrieAppPython/
          zip -r PaulineSoubrieAppPython.zip PaulineSoubrieAppPython/

      - name: Install lftp
        run: sudo apt-get update && sudo apt-get install -y lftp

      - name: Upload zip to FTP
        env:
            FTP_HOST: ${{ secrets.FTP_HOST }}
            FTP_USER: ${{ secrets.FTP_USER }}
            FTP_PASSWORD: ${{ secrets.FTP_PASSWORD }}
            FTP_PATH: ${{ secrets.FTP_PATH }}
        run: |
          lftp -u "$FTP_USER","$FTP_PASSWORD" "$FTP_HOST" <<EOF
          set ssl:verify-certificate no
          cd $FTP_PATH
          put PaulineSoubrieAppPython.zip
          bye
          EOF


